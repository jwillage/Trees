---
title: "Accuracy"
author: "Joe Willage"
date: "March 30, 2016"
output: 
  html_document: 
    keep_md: yes
---

```{r, include = FALSE}
library(knitr)
```

```{r global_options, include = FALSE}
knitr::opts_chunk$set(fig.width = 7, fig.height = 7, fig.path='Figs/', 
                      warning = FALSE, message = FALSE, cache = TRUE)
```

This is an exploration to achieve higher accuracy in mapping latitude and longitude to a street segment. Here a segment is defined as a section of street bounded by two other streets. The end goal is an abstracted pattern, but the motivation is to more accurately map trees in New York City to a specific block. 

The previous analysis left off by stating that an answer was reached, "but how valid is it?" Some inconsistancies were noted, specifically with the block that had the highest reported TPM. Recall the graphic that went with this statement. 

```{r, warning = FALSE, message = FALSE}
library(ggmap)
library(knitr)
library(rjson)
library(dplyr)
library(tidyr)
```

```{r, include = FALSE}
treeMap <- readRDS("rds/treeMap.les.rds")
blocks.les <- readRDS("rds/blocks.corrected.les.rds")
```

```{r sewardPark}
map.sewardPark <- get_map(location = "40.71597,-73.9889687", zoom = 17, maptype = "toner-lines")
ggmap(map.sewardPark) + 
   geom_point(data = treeMap[treeMap$blockId == 35,],
              aes(x = lon, y = lat, size = stumpDiam), alpha = 0.35, color = "chartreuse") +
   scale_size(range = c(5, 7)) +
   theme_nothing()
```

And note that all of these trees mapped to the block of Grand b/w Clinton and Suffolk, when most actually lie on Clinton St. The southmost tree mapped to this block is the following.

```{r}
block.35 <- treeMap[treeMap$blockId == 35, ]
head(block.35[order(block.35$lat), ], 1)
```

Tree 165907 is reverse geocoded as 410 Grand, but viewing the full tree data from the Tree Map website returns the nearest address as 187 Clinton, much more accurate. This may prove to be a useful alternative.  

However, the Geonames Find Nearby Streets (FNS) API provids another useful match. It's not the exact address that's needed for any tree, it's just the nearest street. In fact, that API provides not only the nearest street, but also the to/from addresses of the segment. A takeaway from the first analysis is that mixing and matching geocoding services gets messy. In attempt to minimize error, only the Geonames family of APIs will be used.  

For the tree of interest, here is the result from the Geonames Find Nearby Streets call.

```{r}
user <- readLines("../../geonames.txt")
fns.url <- paste0("http://api.geonames.org/findNearbyStreetsJSON?&username=", user, "&")
fns.parms <- paste0("lat=", block.35[order(block.35$lat), ][1, "lat"], 
                               "&lng=", block.35[order(block.35$lat), ][1, "lon"])
seg <- fromJSON(file = paste0(fns.url, fns.parms))
seg <- sapply(seg$streetSegment, function(i) c(i$name, i$fraddl, i$fraddr, i$toaddl, i$toaddr, 
                                              i$mtfcc, i$zip, i$postalcode, i$distance, i$line))
segments <- seg %>% t %>% as.data.frame(stringsAsFactors = FALSE) %>% 
            setNames(c("street",	"fraddl", "fraddr",	"toaddl", "toaddr",	 "mtfcc",	"zip", 
                       "distance", "line"))
segments[, 1:8]
```

This useful result set returns the to and from addresses for both sides of the street, as well as the distance from the street (which is how the results are ordered). This may be useful in validation. A final component, not included in the above table, is the coordinate line of each segment. This allows for drawing a multi-segment line on a map, another useful tool in validation. Plotting these street segments results in the following

```{r}
segments[1, "line"]
segments$id <- seq_along(segments$street)
lines.list <- strsplit(segments$line, ",")
lines <- data.frame()
for (segment in 1:length(lines.list)){
  lines <- rbind(lines, cbind(segment, lines.list[[segment]]))
}
lines$V2 <- as.character(lines$V2)
lines <- separate(lines, V2, c("lon", "lat"), " ")
lines$lon <- as.numeric(lines$lon)
lines$lat <- as.numeric(lines$lat)
```

```{r clinton lines}
# relevel to separate similar color lines
lines$segment <- factor(lines$segment, levels(lines$segment)[c(3, 6, 7, 2, 8, 9, 1, 5, 4, 10)])
means <- lines %>% group_by(segment) %>% summarize(lat = mean(lat), lon = mean(lon))
ggmap(map.sewardPark) + 
   geom_line(data = lines, aes(x = lon, y = lat, color = segment), size = 4) +
   theme_nothing() +
   geom_point(data = block.35[order(block.35$lat), ][1, ], aes(x = lon, y = lat), 
              size = 10) +
   geom_point(data = block.35[order(block.35$lat), ][1, ], aes(x = lon, y = lat), 
              size = 8, color = "red") +
   geom_text(data = means, aes(x = lon, y = lat, label = segment), size = 6)
```

The point of interest is indicated by the red dot, and each returned segment is uniquely colored. The first segment returned is definitely the most correct: Clinton from 166 - 185. Segment 2 is not wanted, and is actually just a sidewalk from Clinton to Essex. Segment 3 is the other segment that completes this block. Segments 4 - 10 are not part of the block. **The task at hand is to create a reproducible process that groups segments 1 and 3 into a block, and eliminates the other results**.  

The approach involves the Geonames Find Nearest Intersection (FNI) API. Each segment previously returned from FNS will have it's two endpoints passed into FNI. The order of rules is as follows:  

1) Segments are evaluated in the order of minimal `distance` from the point. The first segment will act as the reference point. Segments may be considered to be part of the block if their `street` is the same value as that of the first segment.   
1) A call is made to the FNI API using the segment's first and last coordinates.  
2) Endpoints that are within X `distance` of their nearest intersection are marked as a block end. X is close to 0.
2) If block has two ends, exit the process.  
3) If block has less than two ends, repeat for remaining segments.   

An example with the previous data is as follows:  
Segment 1 is the reference point and an FNI call is made with each of it's endpoints. The results are distinct. The distance of first endpoint is 0. The distance of the second endpoint is 0.7. Endpoint 1 is added as a block end. The block is still incomplete, process next segment. 

The street of segment 2 does not match the reference (segment 1). It's street name is actually the empty string. Skip this segment.  

Segment 3 has a matching street name, "Clinton St". The FNI calls are made for both endpoints. Distinct endpoints are returned. Endpoint 1 has distance 0.7, and endpoint 2 has distance 0. Endpoint 2 is added as a block end. The block now has two ends and is considered complete. The process exits.  

The entire process looks as follows:  

```{r single block}
blocks <- data.frame()
tmpBlock <- data.frame()
fni.url <- paste0("http://api.geonames.org/findNearestIntersectionJSON?&username=", user, "&")
for (segment in 1 : nrow(segments)) {
  primary <- segments[1, "street"]
  if (segments[segment, "street"] != primary) {
    next
  }
  fni.parms1 <- paste0("lat=", lines[lines$segment == segment, "lat"][1], 
                       "&lng=", lines[lines$segment == segment, "lon"][1])
  int1 <- fromJSON(file = paste0(fni.url, fni.parms1))
  fni.parms2 <- paste0("lat=", tail(lines[lines$segment == segment, "lat"], 1), 
                       "&lng=", tail(lines[lines$segment == segment, "lon"], 1))
  int2 <- fromJSON(file = paste0(fni.url, fni.parms2))

  if (int1$intersection$distance < 0.001) {
    streets <- c(int1$intersection$street1, int1$intersection$street2)
    street <- streets[streets != primary]
    tmpBlock <- rbind(tmpBlock, 
                      data.frame(segment, street = street,
                                 lat = int1$intersection$lat, lon = int1$intersection$lng, 
                                 stringsAsFactors = FALSE))
  } 
  if (int2$intersection$distance < 0.001) {
    streets <- c(int2$intersection$street1, int2$intersection$street2)
    street <- streets[streets != primary]
    tmpBlock <- rbind(tmpBlock, 
                      data.frame(segment, street = street,
                                 lat = int2$intersection$lat, lon = int2$intersection$lng, 
                                 stringsAsFactors = FALSE))
  } 
  if (nrow(tmpBlock) >= 2) {
    blocks <- rbind(blocks, cbind(nrow(blocks) + 1, primary, tmpBlock[1, ], tmpBlock[2, ]))
    break
  }
}

names(blocks) <- c("id", "primary.street", "cross1.segment", "cross1.street", "cross1.lat",
                   "cross1.lon", "cross2.segment", "cross2.street", "cross2.lat", "cross2.lon")
blocks
```

The method works well for a single point. The next challenge is iterating through a list of points, checking if they belong to an existing block or if a new block needs to be created. With this process, the FNS API is called for each point and a matching blocks is found. This ensures **accuracy**. A less expensive approach may be to create for each block a polygon (ie thin rectangle) and check if the point lies within. 

```{r}
getSegments <- function(lat, lon) {
  fns.parms <- paste0("lat=", lat, "&lng=", lon)
  seg <- fromJSON(file = paste0(fns.url, fns.parms))
  seg <- sapply(seg$streetSegment, function(i) c(i$name, i$fraddl, i$fraddr, i$toaddl, i$toaddr, 
                                                i$mtfcc, i$zip, i$postalcode, i$distance, i$line))
  segments <- seg %>% t %>% as.data.frame(stringsAsFactors = FALSE) %>% 
              setNames(c("street",	"fraddl", "fraddr",	"toaddl", "toaddr",	 "mtfcc",	"zip", 
                         "distance", "line"))
  # grab first and last coordinate for each segment
  segments[, c("coord1", "coord2")] <- t(sapply(strsplit(segments$line, ","), 
                                                function(z) c(z[1], z[length(z)])))
  segments <- segments %>% separate(coord1, c("lon1", "lat1"), " ") %>% 
              separate(coord2, c("lon2", "lat2"), " ") 
  segments$id <- seq_along(segments$street)
  segments[, c(1:8, 10:14)]
} 
```

A `getSegments` function is broken out to find all the nearest segments to a given point. The code to grab the beginning and ending coordinates for a segment is streamlined in an sapply statement. The complete lines are disgarded, as can be seen by the absence of column 9 in the final statement.  

Iterating through the list of trees will look as follows.  

```{r mapping loop}
# seed blocks table with correct data types
blocks <- data.frame(id = 1, primary.street = "Clinton St", cross1.segment = 1, 
                     cross1.street = "E Broadway", cross1.lat = "40.715952", 
                     cross1.lon = "-73.986721", cross2.segment = 1, cross2.street = "Grand St",
                     cross2.lat = "40.715952", cross2.lon = "-73.986721", count = 0, 
                     stringsAsFactors = FALSE)
err <- NULL
tmpBlock <- NULL
treeMap$blockId <- NULL
for (tree in 1:661) { #nrow(treeMap)
  segments <- getSegments(treeMap[tree, "lat"], treeMap[tree, "lon"])
  primary <- segments[1, "street"]
  tmpBlock <- data.frame()
  for (segment in 1 : nrow(segments)) {
    if (segments[segment, "street"] != primary) {
      next
    }
    fni.parms1 <- paste0("lat=", segments[segment, "lat1"], 
                         "&lng=", segments[segment, "lon1"])
    int1 <- fromJSON(file = paste0(fni.url, fni.parms1))
    fni.parms2 <- paste0("lat=", segments[segment, "lat2"], 
                         "&lng=", segments[segment, "lon2"])
    int2 <- fromJSON(file = paste0(fni.url, fni.parms2))
  
    if (int1$intersection$distance < 0.001) {
      streets <- c(int1$intersection$street1, int1$intersection$street2)
      street <- streets[streets != primary]
      tmpBlock <- rbind(tmpBlock, 
                        data.frame(segment, street = street,
                                   lat = int1$intersection$lat, lon = int1$intersection$lng, 
                                   stringsAsFactors = FALSE))
    } 
    if (int2$intersection$distance < 0.001) {
      streets <- c(int2$intersection$street1, int2$intersection$street2)
      street <- streets[streets != primary]
      tmpBlock <- rbind(tmpBlock, 
                        data.frame(segment, street = street,
                                   lat = int2$intersection$lat, lon = int2$intersection$lng, 
                                   stringsAsFactors = FALSE))
    } 
     if (nrow(tmpBlock) == 2) {
       minStreet <- which(tmpBlock$street == min(tmpBlock$street))
       tmpBlock <- cbind(tmpBlock[minStreet, ], tmpBlock[-minStreet, ])
       names(tmpBlock) <- c("cross1.segment", "cross1.street", "cross1.lat", "cross1.lon",
                            "cross2.segment", "cross2.street", "cross2.lat", "cross2.lon")
       break
     } else if (nrow(tmpBlock) > 2) {
       # error caught in the below null check
       tmpBlock <- NULL
       break
     }
  }
  if (is.null(tmpBlock$cross1.segment) | is.null(tmpBlock$cross2.segment)) {
    # 2 endpoints were not found in the list of segments
    err <<- c(err, tree)
    tmpBlock <- NULL
    next
  }
  x <- inner_join(tmpBlock, blocks, 
                  by = c("cross1.lat" = "cross1.lat", "cross1.lon" = "cross1.lon",
                         "cross2.lat" = "cross2.lat", "cross2.lon" = "cross2.lon"))
  if (nrow(x) > 0) {
    # block exists
    blocks[blocks$id == x$id, "count"] <- blocks[blocks$id == x$id, "count"] + 1
    treeMap[tree, "blockId"] <- blocks[blocks$id == x$id, "id"]
  } else{
    blocks <- rbind(blocks, 
                    cbind(id = nrow(blocks) + 1, primary.street = primary, tmpBlock, count = 1))
    treeMap[tree, "blockId"] <- nrow(blocks)
  }
}
```

Most of the points are successfully mapped to blocks. There are a few errors, such as the following, the segments related to point 662.  

```{r, include = FALSE}
segment.662 <- readRDS("rds/point662.segment.rds")
means <- segment.662 %>% group_by(segment) %>% summarize(lat = mean(lat), lon = mean(lon))
```

```{r wburg bridge}
wburgBridge <- get_map(location = "40.7169942,-73.9859083", zoom = 17, maptype = "toner-lines")
ggmap(wburgBridge) +
  geom_line(data = segment.662, aes(x = lon, y = lat, color = segment), size = 4) +
  theme_nothing() +
  geom_point(data = treeMap[662, ], aes(x = lon, y = lat), size = 10) + 
  geom_point(data =treeMap[662, ], aes(x = lon, y = lat), size = 8, color = "red") +
  geom_text(data = means, aes(x = lon, y = lat, label = segment), size = 6)
```

The point is located on Delancey St b/w Clinton and Ridge. However, the segments returned by the FNS API do not form the complete block. Segment 1 accurately forms part of the block, but the portion closest to Ridge is missing. Even with the radius set to the max of 1 km, no additional segments are returned. In this case, the above loop threw an error because both block ends have the same name (`minStreet` is comprised of 2 values so the `cbind` fails). Error-checking for this stype of situation can be included, but ultimately the block has to be added manually.  

Point 662 actually halted execution, but errors were also captured in cases where 2 endpoints were not found.  

```{r}
length(err)
errTable <- table(treeMap[err, "street"])
errTable
```

Out of the `r length(err)` errors recorded, the majority are on `r names(errTable[errTable == max(errTable)])`. Looking at the data, those points lie on a dead-end street which indeed has only a single intersection. How can that be recorded in the data? 