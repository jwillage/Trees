---
title: "Accuracy"
author: "Joe Willage"
date: "March 30, 2016"
output: 
  html_document: 
    keep_md: yes
---

```{r, include = FALSE}
library(knitr)
```

```{r global_options, include = FALSE}
knitr::opts_chunk$set(fig.width = 7, fig.height = 7, fig.path='Figs/', 
                      warning = FALSE, message = FALSE, cache = TRUE)
```

This is an exploration to achieve higher accuracy in mapping latitude and longitude to a street segment. Here a segment is defined as a section of street bounded by two other streets. The end goal is an abstracted pattern, but the motivation is to more accurately map trees in New York City to a specific block. 

The previous analysis left off by stating that an answer was reached, "but how valid is it?" Some inconsistancies were noted, specifically with the block that had the highest reported TPM. Recall the graphic that went with this statement. 

```{r, warning = FALSE, message = FALSE}
library(ggmap)
library(knitr)
library(rjson)
library(dplyr)
library(tidyr)
```

```{r, include = FALSE}
treeMap <- readRDS("rds/treeMap.les.rds")
blocks.les <- readRDS("rds/blocks.corrected.les.rds")
```

```{r sewardPark}
map.sewardPark <- get_map(location = "40.71597,-73.9889687", zoom = 17, maptype = "toner-lines")
ggmap(map.sewardPark) + 
   geom_point(data = treeMap[treeMap$blockId == 35,],
              aes(x = lon, y = lat, size = stumpDiam), alpha = 0.35, color = "chartreuse") +
   scale_size(range = c(5, 7)) +
   theme_nothing()
```

And note that all of these trees mapped to the block of Grand b/w Clinton and Suffolk, when most actually lie on Clinton St. The southmost tree mapped to this block is the following.

```{r}
block.35 <- treeMap[treeMap$blockId == 35, ]
head(block.35[order(block.35$lat), ], 1)
```

Tree 165907 is reverse geocoded as 410 Grand, but viewing the full tree data from the Tree Map website returns the nearest address as 187 Clinton, much more accurate. This may prove to be a useful alternative.  

However, the Geonames Find Nearby Streets (FNS) API provids another useful match. It's not the exact address that's needed for any tree, it's just the nearest street. In fact, that API provides not only the nearest street, but also the to/from addresses of the segment. A takeaway from the first analysis is that mixing and matching geocoding services gets messy. In attempt to minimize error, only the Geonames family of APIs will be used.  

For the tree of interest, here is the result from the Geonames Find Nearby Streets call.

```{r}
user <- readLines("../../geonames.txt")
fns.url <- paste0("http://api.geonames.org/findNearbyStreetsJSON?&username=", user, "&")
fns.parms <- paste0("lat=", block.35[order(block.35$lat), ][1, "lat"], 
                               "&lng=", block.35[order(block.35$lat), ][1, "lon"])
seg <- fromJSON(file = paste0(fns.url, fns.parms))
seg <- sapply(seg$streetSegment, function(i) c(i$name, i$fraddl, i$fraddr, i$toaddl, i$toaddr, 
                                              i$mtfcc, i$zip, i$postalcode, i$distance, i$line))
segments <- seg %>% t %>% as.data.frame(stringsAsFactors = FALSE) %>% 
            setNames(c("street",	"fraddl", "fraddr",	"toaddl", "toaddr",	 "mtfcc",	"zip", 
                       "distance", "line"))
segments[, 1:8]
```

This useful result set returns the to and from addresses for both sides of the street, as well as the distance from the street (which is how the results are ordered). This may be useful in validation. A final component, not included in the above table, is the coordinate line of each segment. This allows for drawing a multi-segment line on a map, another useful tool in validation. Plotting these street segments results in the following

```{r}
segments[1, "line"]
segments$id <- seq_along(segments$street)
lines.list <- strsplit(segments$line, ",")
lines <- data.frame()
for (segment in 1:length(lines.list)){
  lines <- rbind(lines, cbind(segment, lines.list[[segment]]))
}
lines$V2 <- as.character(lines$V2)
lines <- separate(lines, V2, c("lon", "lat"), " ")
lines$lon <- as.numeric(lines$lon)
lines$lat <- as.numeric(lines$lat)
```

```{r clinton lines}
# relevel to separate similar color lines
lines$segment <- factor(lines$segment, levels(lines$segment)[c(3, 6, 7, 2, 8, 9, 1, 5, 4, 10)])
means <- lines %>% group_by(segment) %>% summarize(lat = mean(lat), lon = mean(lon))
ggmap(map.sewardPark) + 
   geom_line(data = lines, aes(x = lon, y = lat, color = segment), size = 4) +
   theme_nothing() +
   geom_point(data = block.35[order(block.35$lat), ][1, ], aes(x = lon, y = lat), 
              size = 10) +
   geom_point(data = block.35[order(block.35$lat), ][1, ], aes(x = lon, y = lat), 
              size = 8, color = "red") +
   geom_text(data = means, aes(x = lon, y = lat, label = segment), size = 6)
```

The point of interest is indicated by the red dot, and each returned segment is uniquely colored. The first segment returned is definitely the most correct: Clinton from 166 - 185. Segment 2 is not wanted, and is actually just a sidewalk from Clinton to Essex. Segment 3 is the other segment that completes this block. Segments 4 - 10 are not part of the block. **The task at hand is to create a reproducible process that groups segments 1 and 3 into a block, and eliminates the other results**.  

The approach involves the Geonames Find Nearest Intersection (FNI) API. Each segment previously returned from FNS will have it's two endpoints passed into FNI. The order of rules is as follows:  

1) Segments are evaluated in the order of minimal `distance` from the point. The first segment will act as the reference point. Segments may be considered to be part of the block if their `street` is the same value as that of the first segment.   
1) A call is made to the FNI API using the segment's first and last coordinates.  
2) Endpoints that are within X `distance` of their nearest intersection are marked as a block end. X is close to 0.
2) If block has two ends, exit the process.  
3) If block has less than two ends, repeat for remaining segments.   

An example with the previous data is as follows:  
Segment 1 is the reference point and an FNI call is made with each of it's endpoints. The results are distinct. The distance of first endpoint is 0. The distance of the second endpoint is 0.7. Endpoint 1 is added as a block end. The block is still incomplete, process next segment. 

The street of segment 2 does not match the reference (segment 1). It's street name is actually the empty string. Skip this segment.  

Segment 3 has a matching street name, "Clinton St". The FNI calls are made for both endpoints. Distinct endpoints are returned. Endpoint 1 has distance 0.7, and endpoint 2 has distance 0. Endpoint 2 is added as a block end. The block now has two ends and is considered complete. The process exits.  

The entire process looks as follows:  

```{r single block}
blocks <- data.frame()
tmpBlock <- data.frame()
fni.url <- paste0("http://api.geonames.org/findNearestIntersectionJSON?&username=", user, "&")
for (segment in 1 : nrow(segments)) {
  primary <- segments[1, "street"]
  if (segments[segment, "street"] != primary) {
    next
  }
  fni.parms1 <- paste0("lat=", lines[lines$segment == segment, "lat"][1], 
                       "&lng=", lines[lines$segment == segment, "lon"][1])
  int1 <- fromJSON(file = paste0(fni.url, fni.parms1))
  fni.parms2 <- paste0("lat=", tail(lines[lines$segment == segment, "lat"], 1), 
                       "&lng=", tail(lines[lines$segment == segment, "lon"], 1))
  int2 <- fromJSON(file = paste0(fni.url, fni.parms2))

  if (int1$intersection$distance < 0.001) {
    streets <- c(int1$intersection$street1, int1$intersection$street2)
    street <- streets[streets != primary]
    tmpBlock <- rbind(tmpBlock, 
                      data.frame(segment, street = street,
                                 lat = int1$intersection$lat, lon = int1$intersection$lng, 
                                 stringsAsFactors = FALSE))
  } 
  if (int2$intersection$distance < 0.001) {
    streets <- c(int2$intersection$street1, int2$intersection$street2)
    street <- streets[streets != primary]
    tmpBlock <- rbind(tmpBlock, 
                      data.frame(segment, street = street,
                                 lat = int2$intersection$lat, lon = int2$intersection$lng, 
                                 stringsAsFactors = FALSE))
  } 
  if (nrow(tmpBlock) >= 2) {
    blocks <- rbind(blocks, cbind(nrow(blocks) + 1, primary, tmpBlock[1, ], tmpBlock[2, ]))
    break
  }
}

names(blocks) <- c("id", "primary.street", "cross1.segment", "cross1.street", "cross1.lat",
                   "cross1.lon", "cross2.segment", "cross2.street", "cross2.lat", "cross2.lon")
blocks
```

