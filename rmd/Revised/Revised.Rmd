---
title: "Revised"
author: "Joe Willage"
date: "April 14, 2016"
output: 
  html_document: 
    keep_md: yes
---

```{r, include = FALSE}
library(knitr)
```

```{r global_options, include = FALSE}
knitr::opts_chunk$set(fig.width = 7, fig.height = 7, fig.path='Figs/', 
                      warning = FALSE, message = FALSE, cache = TRUE)
```

This is the third and final(?) installment in a series discussing trees and geocoordinate accuracy in New York City. The [first article]() established a baseline and connected to the NYC Tree Map data source[^1]. The [second article]() focused on achieving a higher accuracy in mapping points to street blocks. This article brings the other two together, applying generic coordinate mapping to the full list* of NYC trees.  

Unfortunately, the island of Manhattan doesn't fit easily into a rectangle, which is what's returned from the Tree Map API. An MBB convering Manhattan is defined, and all trees outside of that area are pruned.  

```{r, warning = FALSE, message = FALSE}
library(ggmap)
library(knitr)
library(rjson)
library(dplyr)
library(tidyr)
library(sp)
library(data.table)
```

```{r, eval = FALSE}
border.corner.sw.lat <- "40.7006164"
border.corner.sw.long <- "-74.020083"
border.corner.ne.lat <- "40.8778038"
border.corner.ne.long <- "-73.9085997"

treemap.url <- paste("https://tree-map.nycgovparks.org/points",
              border.corner.sw.lat, border.corner.sw.long, 
              border.corner.ne.lat, border.corner.ne.long,
              "undefined", sep = "/")
treeMap <- data.frame()
# Retrieve 1000 trees at a time
for (i in 1:87) { # ~64K trees in Manh + various trees from BK, Qns, Bx that are in the box = 87K
  raw <- fromJSON(file = paste(treemap.url, i, 1000, sep = "/"))
  tmp <- lapply(raw$item, function(x) {
    c(x$id, x$lat, x$lng, x$stumpdiameter, x$species$id)
  })
  tmpdf <- data.frame(matrix(unlist(tmp), ncol = 5, byrow = TRUE), stringsAsFactors = FALSE)
  treeMap <- rbind(treeMap, tmpdf)
}
names(treeMap)[1:5] <- c("id", "lat", "lon", "stumpDiam", "speciesId")
```

```{r read treeMap, include = FALSE}
treeMap <- readRDS("rds/treeMap.rds") 
```

```{r}
head(treeMap)
```

Next, the trees are subset to just those in Manhattan. The first step is to retrieve a shape file describing Manhattan[^2].     

```{r draw Manhattan}
shapes <- fromJSON(file = paste0("http://services5.arcgis.com/GfwWNkhOj9bNBqoJ/arcgis/rest/",
                                 "services/nybb/FeatureServer/0/query?where=1=1&outFields=*&",
                                 "outSR=4326&f=geojson"))
boroughs <- sapply(shapes$features, function(x) x$properties$BoroName)
manh <- which(boroughs == "Manhattan")
coords.manh <- shapes$features[[manh]]$geometry$coordinates
df.manh <- data.frame(matrix(unlist(coords.manh), ncol = 2, byrow = TRUE), stringsAsFactors = FALSE)
names(df.manh) <- c("lon", "lat")
ggplot(data = df.manh, aes(x = lon, y = lat)) +
  geom_polygon() +
  scale_x_continuous(limits = c(-74.08, -73.85))
```

This works pretty well, except for the giant line down the middle of the city causing half of Manhattan to not exist. 

```{r seq_along}
df.manh$num <- seq_along(df.manh$lon)
g <- ggplot(data = df.manh, aes(x = lon, y = lat, num = num)) +
      geom_polygon() + 
      geom_point(aes(color = num)) +
      scale_color_continuous(low = "blue", high = "red") 
g
```

The area of interest is the main island of Manhattan. It looks like that's the polygon described by the bright red through purple points, starting and ending at Inwood. Using the legend, that appears to be about points 1100 and up (fine-tuned to this number with trial and error). The weird island floating up by the bronx should be removed as well (points > 6130). 

```{r manhattan subset}
df.manh.subset <- subset(df.manh, num > 1100 & num < 6130)
g <- ggplot(data = df.manh.subset, aes(x = lon, y = lat, num = num)) +
      geom_polygon() + 
      geom_point(aes(color = num)) +
      scale_color_continuous(low = "blue", high = "red") 
g
```

Better.  

```{r}
points.manh <- point.in.polygon(treeMap$lon, treeMap$lat, 
                                df.manh.subset[, "lon"],  df.manh.subset[, "lat"])
treeMap <- treeMap[points.manh > 0, ]
```

Now that the correct points are collected, they need to be mapped to a street block, which requires simultaneously building a block table. See the [last post]() for detailed descriptions of the following functions.  

```{r block table, eval = FALSE}
user <- readLines("../../geonames.txt")
fns.url <- paste0("http://api.geonames.org/findNearbyStreetsJSON?username=", user, "&")
fni.url <- paste0("http://api.geonames.org/findNearestIntersectionJSON?username=", user, "&")

getSegments <- function(lat, lon) {
  fns.parms <- paste0("lat=", lat, "&lng=", lon)
  seg <- fromJSON(file = paste0(fns.url, fns.parms))
  seg <- sapply(seg$streetSegment, function(i) c(i$name, i$fraddl, i$fraddr, i$toaddl, i$toaddr, 
                                                i$mtfcc, i$zip, i$postalcode, i$distance, i$line))
  segments <- seg %>% t %>% as.data.frame(stringsAsFactors = FALSE) %>% 
              setNames(c("street",	"fraddl", "fraddr",	"toaddl", "toaddr",	 "mtfcc",	"zip", 
                         "distance", "line"))
  segments[, c("coord1", "coord2")] <- t(sapply(strsplit(segments$line, ","), 
                                                function(z) c(z[1], z[length(z)])))
  segments <- segments %>% separate(coord1, c("lon1", "lat1"), " ") %>% 
              separate(coord2, c("lon2", "lat2"), " ") 
  segments$id <- seq_along(segments$street)
  segments[, c(1:8, 10:14)]
} 

getStreet <- function(primary, intersection) {
  streets <- c(intersection$street1, intersection$street2)
  street <- streets[streets != primary]
  if (length(street) > 1) {
   street <- paste(street, collapse = " & ")
  }  
  street
}

# seed blocks table with correct data types
blocks <- data.frame(id = 1, primary.street = "Clinton St", cross1.segment = 1, 
                     cross1.street = "E Broadway", cross1.lat = "40.715952", 
                     cross1.lon = "-73.986721", cross2.segment = 1, cross2.street = "Grand St",
                     cross2.lat = "40.715952", cross2.lon = "-73.986721", count = 0, 
                     stringsAsFactors = FALSE)
err <- NULL
tmpBlock <- NULL
treeMap$blockId <- NULL
for (tree in 1:nrow(treeMap)) { 
  tryCatch({
    print(tree)
  segments <- getSegments(todo[tree, "lat"], todo[tree, "lon"])
  primary <- segments[1, "street"]
  tmpBlock <- data.frame()
  for (segment in 1 : nrow(segments)) {
    if (segments[segment, "street"] != primary) {
      next
    }
    fni.parms1 <- paste0("lat=", segments[segment, "lat1"], 
                         "&lng=", segments[segment, "lon1"])
    int1 <- fromJSON(file = paste0(fni.url, fni.parms1))
    fni.parms2 <- paste0("lat=", segments[segment, "lat2"], 
                         "&lng=", segments[segment, "lon2"])
    int2 <- fromJSON(file = paste0(fni.url, fni.parms2))

    if (segment == 1) {
      primary.int1 <- int1
      primary.int2 <- int2
    }

    if (int1$intersection$distance < 0.001) {
      tmpBlock <- rbind(tmpBlock, 
                        data.frame(segment, street = getStreet(primary, int1$intersection),
                                   lat = int1$intersection$lat, lon = int1$intersection$lng, 
                                   stringsAsFactors = FALSE))
    } 
    if (int2$intersection$distance < 0.001) {
      tmpBlock <- rbind(tmpBlock, 
                        data.frame(segment, street = getStreet(primary, int2$intersection),
                                   lat = int2$intersection$lat, lon = int2$intersection$lng, 
                                   stringsAsFactors = FALSE))
    } 
    if (nrow(tmpBlock) > 2) {
      # error state with incomplete segments. Use primary segment for full block
       tmpBlock <- rbind(data.frame(1, street = getStreet(primary, primary.int1$intersection),
                                    lat = int1$intersection$lat, lon = int1$intersection$lng, 
                                    stringsAsFactors = FALSE),
                         data.frame(1, street = getStreet(primary, primary.int2$intersection),
                                    lat = int1$intersection$lat, lon = int1$intersection$lng, 
                                    stringsAsFactors = FALSE))       
     }
     if (nrow(tmpBlock) == 2) {
       minStreet <- which(tmpBlock$street == min(tmpBlock$street))
       if (length(minStreet) > 1) {
         tmpBlock <- cbind(tmpBlock[1, ], "NA", "NA", "NA", "NA")
       } else{
         tmpBlock <- cbind(tmpBlock[minStreet, ], tmpBlock[-minStreet, ])
       }
       names(tmpBlock) <- c("cross1.segment", "cross1.street", "cross1.lat", "cross1.lon",
                            "cross2.segment", "cross2.street", "cross2.lat", "cross2.lon")
       break
     } 
  }
  if (is.null(tmpBlock$cross1.segment) | is.null(tmpBlock$cross2.segment)) {
    err <<- c(err, tree)
    tmpBlock <- NULL
    next
  }
  x <- inner_join(tmpBlock, blocks, 
                  by = c("cross1.lat" = "cross1.lat", "cross1.lon" = "cross1.lon",
                         "cross2.lat" = "cross2.lat", "cross2.lon" = "cross2.lon"))
  if (nrow(x) > 0) {
    # block exists
    blocks[blocks$id == x$id, "count"] <- blocks[blocks$id == x$id, "count"] + 1
    todo[tree, "blockId"] <- blocks[blocks$id == x$id, "id"]
  } else{
    blocks <- rbind(blocks, 
                    cbind(id = nrow(blocks) + 1, primary.street = primary, tmpBlock, count = 1))
    todo[tree, "blockId"] <- nrow(blocks)
  }},
  error = function(e){
    # sleep for API limit
    Sys.sleep(60 * 60)
    tree <- tree - 1
  }
)
}
```


```{r, include = FALSE} 
treeMap <- readRDS("rds/treeMap.64397.947.errs.rds") 
blocks <- readRDS("rds/blocks.64397.947.errs.rds")
err <- readRDS("rds/err.64397.rds")
```

```{r}
length(err) 
```

There are a lot of errors, but not too bad relative to the total number of trees mapped (`r paste0(round(length(err)/nrow(treeMap) * 100, 2), "%")`). The previous post introduced k-means clustering to group a block of trees together. The clustering method helps reduce the amount of manual labor, but the number of clusters has to be conservative, and clusters have to be verified. The starting number of clusters is obtained by dividing the number of errors by the median number of trees per block, resulting in `r ceiling(length(err)/median(blocks$count))` clusters. The idea is that each cluster will map to a block.

```{r errors}
map.manh <- get_map(location = "manhattan", zoom = 12, maptype = "toner-lines")
trees.err <- treeMap[err, ]
set.seed(123)
km <- kmeans(cbind(trees.err[, "lat"], trees.err[, "lon"]), 
             centers = ceiling(length(err)/median(blocks$count)), nstart = 50)
trees.err$cluster <- as.factor(km$cluster)
ggmap(map.manh) + 
   geom_point(data = trees.err,
              aes(x = lon, y = lat, color = cluster), alpha = 0.4, size = 8) +
   theme_nothing() 
```

```{r wall street errors}
map.wall <- get_map(location = "40.705873, -74.013200", zoom = 16, maptype = "toner-lines")
means <- trees.err %>% group_by(cluster) %>% summarize(lat = mean(lat), lon = mean(lon))
ggmap(map.wall) + 
   geom_point(data = trees.err,
              aes(x = lon, y = lat, color = cluster), alpha = 0.4, size = 8) +
   geom_text(data = means, aes(x = lon, y = lat, label = cluster), size = 8, color = "red4", 
             alpha = 0.8) +
   theme_nothing() 
```

Unfortunately this doesn't do a good enough job; clusters are comprised of multiple streets, especially cluster 62. 

```{r wall street revised}
set.seed(123)
km <- kmeans(cbind(trees.err[, "lat"], trees.err[, "lon"]), 
             centers = ceiling(length(err)/median(blocks$count)) * 2, nstart = 50)
trees.err$cluster <- as.factor(km$cluster)
means <- trees.err %>% group_by(cluster) %>% summarize(lat = mean(lat), lon = mean(lon))
ggmap(map.wall) + 
   geom_point(data = trees.err,
              aes(x = lon, y = lat, color = cluster), alpha = 0.4, size = 8) +
   geom_text(data = means, aes(x = lon, y = lat, label = cluster), size = 7, color = "red4", 
             alpha = 0.8) +
   theme_nothing() 
```

Doubling the number of clusters does the job, at least for the financial district. And clusters can always be easily combined. 

```{r read corrections, include = FALSE} 
blocks <- readRDS("rds/blocks.corrected.rds")
treeMap <- readRDS("rds/treeMap.corrected.rds") 
trees.err <- readRDS("rds/trees.err.rds") 
```

After manually adding missing blocks and assigning all clusters of trees, the blocks require a little further cleanup. All entries with the same primary and cross streets are collapsed into a single entry. The trees assigned to the collapsed blocks will be assigned the new block ID value. 

```{r collapse blocks}
blocks$idx <- blocks %>% group_indices(primary.street, cross1.street, cross2.street) 
blocks <- as.data.table(blocks) 
blocks.collapse <- blocks[blocks[, .I[order(idx)[1]], by = idx]$V1, 
                          c("idx", "primary.street", "cross1.street", "cross2.street", "cross1.lat",
                            "cross1.lon", "cross2.lat", "cross2.lon"), with = FALSE]
blocks.collapse$count <- tapply(blocks$count, blocks$idx, sum)
treeMap$blockId <- as.character(treeMap$blockId)
treeMap$blockId <- right_join(blocks, treeMap, by = c("id" = "blockId")) %>%  select(idx)
```

This reduces the number of blocks from `r nrow(blocks)` to `r nrow(blocks.collapse)`. They can now be sorted by tree count.

```{r}
head(blocks.collapse[order(blocks.collapse$count, decreasing = TRUE), c(2:4, 9), with = FALSE], 10)
```

handle NA block IDXs. Looks like 92 treeMap$blockIds are null. possibyl from the looping/cycling process. 
leftover <- treeMap[is.na(treeMap$blockId),]. rerun loop for tree in leftover. 
Deep check at streets bw East End ave and york

The Manhattan block with the highest number of trees is Central Park W between W 77th and W 81st, with `r head(blocks.collapse[order(blocks.collapse$count, decreasing = TRUE),]$count, 1)`. While interesting in it's own right, this doesn't take into account the distance of a block. For instance, the "block" along Central Park W is clearly 4 blocks long. To reconcile this issue, a slightly different question is asked: Which block has the highest trees-per-meter (TPM)? The TPM approach as discussed in the [first article]() is applied.  

```{r}
deg2rad <- function(deg) return(deg * pi / 180)

gcd <- function(long1, lat1, long2, lat2) {
  # Computes the great-circle distance between two points using the haversine formula
  #
  # Args:
  #   long1:  Longitude of first point in decimal degrees
  #   lat2:   Latitude of first point in decimal degrees
  #   long2:  Longitude of first point in decimal degrees
  #   lat2:   Latitude of second point in decimal degrees
  #
  # Returns:
  #   The distance in meters
  
  long1 <- deg2rad(long1) 
  lat1 <- deg2rad(lat1)
  long2 <- deg2rad(long2) 
  lat2 <- deg2rad(lat2)
  r <- 6371000
  long.delt <- (long2 - long1)
  lat.delt <- (lat2 - lat1)
  a <- as.numeric(sin(lat.delt / 2)^2 + cos(lat1) * cos(lat2) * sin(long.delt / 2)^2)
  c <- 2 * atan2(sqrt(a), sqrt(1 - a))
  r * c
}
```

Note the application of the Haversine formula assumes all blocks are straight lines from one endpoint to the other. This is generally the case. Another possible solution could incorporate Google Maps, which may give a more precise distance, but with an API rate limit. 


```{r}
blocks.collapse$cross2.lon <- as.numeric(blocks.collapse$cross2.lon)
blocks.collapse$cross2.lat <- as.numeric(blocks.collapse$cross2.lat)
blocks.collapse$cross1.lon <- as.numeric(blocks.collapse$cross1.lon)
blocks.collapse$cross1.lat <- as.numeric(blocks.collapse$cross1.lat)

for (i in 2:nrow(blocks.collapse)) { 
  d <- gcd(blocks.collapse[i, "cross1.lon", with = FALSE], 
           blocks.collapse[i, "cross1.lat", with = FALSE], 
           blocks.collapse[i, "cross2.lon", with = FALSE], 
           blocks.collapse[i, "cross2.lat", with = FALSE])
  blocks.collapse[i, "distance"] <- d 
}

blocks.collapse$tpm <- blocks.collapse$count / blocks.collapse$distance
blocks.real <- blocks.collapse[blocks.collapse$tpm != Inf, ]
```

todo row for blocks.collapse[1,]
fix blocks with lat/lon1 == lat/lon2 (distance inf)


At this point the question of which Manhattan block has the highest TPM can be answered. 

```{r, echo = FALSE}
head(blocks.real[order(blocks.real$tpm, decreasing = TRUE), c(2:4, 9:11), with = FALSE], 1)
```

The top 25 blocks: 

```{r}
top25 <- as.data.frame(head(blocks.real[order(blocks.real$tpm, decreasing = TRUE), ], 25))
top25[, c(2:4, 9:11)]
```

```{r top 25 map}
plotdata <- as.data.frame(
              rbind(as.matrix(top25[, c("idx", "cross1.lat", "cross1.lon"), with = FALSE]),
                    as.matrix(top25[, c("idx", "cross2.lat", "cross2.lon"), with = FALSE])))
plotdata$idx <- as.factor(plotdata$idx)



ggmap(map.manh) + 
    geom_line(data = plotdata, aes(x = cross1.lon, y = cross1.lat, color = idx), size = 6) +
  # geom_point(dat = top25, aes(x = lon.avg, y = lat.avg), size = 6, alpha = 0.7, color = "green") +
   theme_nothing() 
```

instead of above and using lines, plot a point at the average between lat1/lon1 and lat2/lon2
todo calculate distance using the segments in teh main loop. 
consider hex plotting of areas by average tpm. 

[^1]: **New York City Street Tree Map Beta**  
  Interactive map to view details from a city-wide to a single tree level. No official API  
  https://tree-map.nycgovparks.org/points/\<SW lat>\/\<SW lng\>/\<NE lat\>/\<NE lng\>/undefined/
  \<page\>/\<number trees\>  
  View details of a specific tree, including closest address:  
  https://tree-map.nycgovparks.org/tree/full/\<tree-id from points json\>  
  Browser-based map:  
  https://tree-map.nycgovparks.org/ &nbsp;&nbsp;&nbsp;
  
[^2]: **NYC Open Data**  
  Political and Administrative Boundaries, Borough Boundaries (Clipped to Shoreline)
  http://www1.nyc.gov/site/planning/data-maps/open-data/districts-download-metadata.page&nbsp;&nbsp;&nbsp;