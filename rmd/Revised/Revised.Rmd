---
title: "Revised"
author: "Joe Willage"
date: "April 14, 2016"
output: 
  html_document: 
    keep_md: yes
---

```{r, include = FALSE}
library(knitr)
```

```{r global_options, include = FALSE}
knitr::opts_chunk$set(fig.width = 7, fig.height = 7, fig.path='Figs/', 
                      warning = FALSE, message = FALSE, cache = TRUE)
```

This is the third and final installment in a series discussing trees and geocoordinate accuracy in New York City. The [first article]() established a baseline and connected to the NYC Tree Map data source[^1]. The [second article]() focused on achieving a higher accuracy in mapping points to street blocks. This article brings the other two together, applying generic coordinate mapping to the full list of Manhattan street trees.  

The first step is calling the Tree Map API. The API returns a rectangular polygon filled with points representing trees. Unfortunately, the island of Manhattan doesn't fit easily onto a rectangle. So an MBB convering Manhattan is defined, and all trees outside of that area are pruned.  

```{r, warning = FALSE, message = FALSE}
library(ggmap)
library(knitr)
library(rjson)
library(dplyr)
library(tidyr)
library(sp)
library(data.table)
library(hexbin)
```

```{r, eval = FALSE}
border.corner.sw.lat <- "40.7006164"
border.corner.sw.long <- "-74.020083"
border.corner.ne.lat <- "40.8778038"
border.corner.ne.long <- "-73.9085997"

treemap.url <- paste("https://tree-map.nycgovparks.org/points",
              border.corner.sw.lat, border.corner.sw.long, 
              border.corner.ne.lat, border.corner.ne.long,
              "undefined", sep = "/")
treeMap <- data.frame()
# Retrieve 1000 trees at a time
for (i in 1:87) { # ~64K trees in Manh + various trees from BK, Qns, Bx that are in the box = 87K
  raw <- fromJSON(file = paste(treemap.url, i, 1000, sep = "/"))
  tmp <- lapply(raw$item, function(x) {
    c(x$id, x$lat, x$lng, x$stumpdiameter, x$species$id)
  })
  tmpdf <- data.frame(matrix(unlist(tmp), ncol = 5, byrow = TRUE), stringsAsFactors = FALSE)
  treeMap <- rbind(treeMap, tmpdf)
}
names(treeMap)[1:5] <- c("id", "lat", "lon", "stumpDiam", "speciesId")
```

```{r read treeMap, include = FALSE}
treeMap <- readRDS("rds/treeMap.rds") 
```

```{r}
head(treeMap)
```

Next, the trees are subset to just those in Manhattan. The first step here is to retrieve a shape file describing Manhattan[^2].     

```{r draw Manhattan}
shapes <- fromJSON(file = paste0("http://services5.arcgis.com/GfwWNkhOj9bNBqoJ/arcgis/rest/",
                                 "services/nybb/FeatureServer/0/query?where=1=1&outFields=*&",
                                 "outSR=4326&f=geojson"))
boroughs <- sapply(shapes$features, function(x) x$properties$BoroName)
manh <- which(boroughs == "Manhattan")
coords.manh <- shapes$features[[manh]]$geometry$coordinates
df.manh <- data.frame(matrix(unlist(coords.manh), ncol = 2, byrow = TRUE), stringsAsFactors = FALSE)
names(df.manh) <- c("lon", "lat")
ggplot(data = df.manh, aes(x = lon, y = lat)) +
  geom_polygon() +
  scale_x_continuous(limits = c(-74.08, -73.85))
```

This works pretty well, except for the giant line down the middle of the city causing half of Manhattan to not exist.  

To solve this, each point in the polygon is assigned a number, and from that it can be determined which points should stay and which should go. 

```{r seq_along}
df.manh$num <- seq_along(df.manh$lon)
g <- ggplot(data = df.manh, aes(x = lon, y = lat, num = num)) +
      geom_polygon() + 
      geom_point(aes(color = num)) +
      scale_color_continuous(low = "blue", high = "red") 
g
```

The area of interest is the main island of Manhattan. It looks like that's the polygon described by the bright red through purple points, starting and ending at Inwood. Using the legend, that appears to be about points 1100 and up (fine-tuned to this number with trial and error). The weird island floating up by the Bronx should be removed as well (points > 6130). 

```{r manhattan subset}
df.manh.subset <- subset(df.manh, num > 1100 & num < 6130)
g <- ggplot(data = df.manh.subset, aes(x = lon, y = lat, num = num)) +
      geom_polygon() + 
      geom_point(aes(color = num)) +
      scale_color_continuous(low = "blue", high = "red") 
g
```

Better.  

```{r}
points.manh <- point.in.polygon(treeMap$lon, treeMap$lat, 
                                df.manh.subset[, "lon"],  df.manh.subset[, "lat"])
treeMap <- treeMap[points.manh > 0, ]
```

Now that the correct points are collected, they need to be mapped to a street block. That requires simultaneously building a block table. See the [last post]() for detailed explanations of the following functions.  

```{r block table, eval = FALSE}
user <- readLines("../../geonames.txt")
fns.url <- paste0("http://api.geonames.org/findNearbyStreetsJSON?username=", user, "&")
fni.url <- paste0("http://api.geonames.org/findNearestIntersectionJSON?username=", user, "&")

getSegments <- function(lat, lon) {
  fns.parms <- paste0("lat=", lat, "&lng=", lon)
  seg <- fromJSON(file = paste0(fns.url, fns.parms))
  seg <- sapply(seg$streetSegment, function(i) c(i$name, i$fraddl, i$fraddr, i$toaddl, i$toaddr, 
                                                i$mtfcc, i$zip, i$postalcode, i$distance, i$line))
  segments <- seg %>% t %>% as.data.frame(stringsAsFactors = FALSE) %>% 
              setNames(c("street",	"fraddl", "fraddr",	"toaddl", "toaddr",	 "mtfcc",	"zip", 
                         "distance", "line"))
  segments[, c("coord1", "coord2")] <- t(sapply(strsplit(segments$line, ","), 
                                                function(z) c(z[1], z[length(z)])))
  segments <- segments %>% separate(coord1, c("lon1", "lat1"), " ") %>% 
              separate(coord2, c("lon2", "lat2"), " ") 
  segments$id <- seq_along(segments$street)
  segments[, c(1:8, 10:14)]
} 

getStreet <- function(primary, intersection) {
  streets <- c(intersection$street1, intersection$street2)
  street <- streets[streets != primary]
  if (length(street) > 1) {
   street <- paste(street, collapse = " & ")
  }  
  street
}

#todo fix seed coords 
# seed blocks table with correct data types
blocks <- data.frame(id = 1, primary.street = "Clinton St", cross1.segment = 1, 
                     cross1.street = "E Broadway", cross1.lat = "40.715952", 
                     cross1.lon = "-73.986721", cross2.segment = 1, cross2.street = "Grand St",
                     cross2.lat = "40.715952", cross2.lon = "-73.986721", count = 0, 
                     stringsAsFactors = FALSE)
err <- NULL
tmpBlock <- NULL
treeMap$blockId <- NULL
for (tree in 1:nrow(leftover)) { 
  tryCatch({
    print(tree)
  segments <- getSegments(leftover[tree, "lat"], leftover[tree, "lon"])
  primary <- segments[1, "street"]
  tmpBlock <- data.frame()
  for (segment in 1 : nrow(segments)) {
    if (segments[segment, "street"] != primary) {
      next
    }
    fni.parms1 <- paste0("lat=", segments[segment, "lat1"], 
                         "&lng=", segments[segment, "lon1"])
    int1 <- fromJSON(file = paste0(fni.url, fni.parms1))
    fni.parms2 <- paste0("lat=", segments[segment, "lat2"], 
                         "&lng=", segments[segment, "lon2"])
    int2 <- fromJSON(file = paste0(fni.url, fni.parms2))

    if (segment == 1) {
      primary.int1 <- int1
      primary.int2 <- int2
    }

    if (int1$intersection$distance < 0.001) {
      tmpBlock <- rbind(tmpBlock, 
                        data.frame(segment, street = getStreet(primary, int1$intersection),
                                   lat = int1$intersection$lat, lon = int1$intersection$lng, 
                                   stringsAsFactors = FALSE))
    } 
    if (int2$intersection$distance < 0.001) {
      tmpBlock <- rbind(tmpBlock, 
                        data.frame(segment, street = getStreet(primary, int2$intersection),
                                   lat = int2$intersection$lat, lon = int2$intersection$lng, 
                                   stringsAsFactors = FALSE))
    } 
    if (nrow(tmpBlock) > 2) {
      # error state with incomplete segments. Use primary segment for full block
       tmpBlock <- rbind(data.frame(1, street = getStreet(primary, primary.int1$intersection),
                                    lat = int1$intersection$lat, lon = int1$intersection$lng, 
                                    stringsAsFactors = FALSE),
                         data.frame(1, street = getStreet(primary, primary.int2$intersection),
                                    lat = int1$intersection$lat, lon = int1$intersection$lng, 
                                    stringsAsFactors = FALSE))       
     }
     if (nrow(tmpBlock) == 2) {
       minStreet <- which(tmpBlock$street == min(tmpBlock$street))
       if (length(minStreet) > 1) {
         tmpBlock <- cbind(tmpBlock[1, ], NA, NA, NA, NA)
       } else{
         tmpBlock <- cbind(tmpBlock[minStreet, ], tmpBlock[-minStreet, ])
       }
       names(tmpBlock) <- c("cross1.segment", "cross1.street", "cross1.lat", "cross1.lon",
                            "cross2.segment", "cross2.street", "cross2.lat", "cross2.lon")
       break
     } 
  }
  if (is.null(tmpBlock$cross1.segment) | is.null(tmpBlock$cross2.segment)) {
    err <<- c(err, tree)
    tmpBlock <- NULL
    next
  }
  x <- inner_join(tmpBlock, blocks, 
                  by = c("cross1.lat" = "cross1.lat", "cross1.lon" = "cross1.lon",
                         "cross2.lat" = "cross2.lat", "cross2.lon" = "cross2.lon"))
  if (nrow(x) > 0) {
    # block exists
    blocks[blocks$id == x$id, "count"] <- blocks[blocks$id == x$id, "count"] + 1
    leftover[tree, "blockId"] <- blocks[blocks$id == x$id, "id"]
  } else{
    blocks <- rbind(blocks, 
                    cbind(id = nrow(blocks) + 1, primary.street = primary, tmpBlock, count = 1))
    leftover[tree, "blockId"] <- nrow(blocks)
  }},
  error = function(e){
    print("err")
    Sys.sleep(60 * 60)  # sleep for API limit
    tree <- tree - 1
  })
}
```


```{r, include = FALSE} 
treeMap <- readRDS("rds/treeMap.64397.947.errs.rds") 
blocks <- readRDS("rds/blocks.64397.947.errs.rds")
err <- readRDS("rds/err.64397.rds")
```

```{r}
length(err) 
```

There are a lot of errors left over, but not too bad relative to the total number of trees mapped (`r paste0(round(length(err)/nrow(treeMap) * 100, 2), "%")`). The previous post introduced k-means clustering to group a block of trees together. The clustering method helps reduce the amount of manual labor, but the number of clusters has to be conservative, and clusters have to be verified. The starting number of clusters is obtained by dividing the number of errors by the median number of trees per block, resulting in `r ceiling(length(err)/median(blocks$count))` clusters. The idea is that each cluster will map to a block.

```{r errors}
map.manh <- get_map(location = "manhattan", zoom = 12, maptype = "toner-lines")
trees.err <- treeMap[err, ]
set.seed(123)
km <- kmeans(cbind(trees.err[, "lat"], trees.err[, "lon"]), 
             centers = ceiling(length(err)/median(blocks$count)), nstart = 50)
trees.err$cluster <- as.factor(km$cluster)
ggmap(map.manh) + 
   geom_point(data = trees.err,
              aes(x = lon, y = lat, color = cluster), alpha = 0.4, size = 8) +
   theme_nothing() 
```

Zooming in on one neighborhood...  

```{r wall street errors}
map.wall <- get_map(location = "40.705873, -74.013200", zoom = 16, maptype = "toner-lines")
means <- trees.err %>% group_by(cluster) %>% summarize(lat = mean(lat), lon = mean(lon))
ggmap(map.wall) + 
   geom_point(data = trees.err,
              aes(x = lon, y = lat, color = cluster), alpha = 0.4, size = 8) +
   geom_text(data = means, aes(x = lon, y = lat, label = cluster), size = 8, color = "red4", 
             alpha = 0.8) +
   theme_nothing() 
```

Unfortunately this clustering doesn't do a good enough job; clusters are comprised of multiple streets, especially cluster 62. The next attempt doubles the number of clusters. 

```{r wall street revised}
set.seed(123)
km <- kmeans(cbind(trees.err[, "lat"], trees.err[, "lon"]), 
             centers = ceiling(length(err)/median(blocks$count)) * 2, nstart = 50)
trees.err$cluster <- as.factor(km$cluster)
means <- trees.err %>% group_by(cluster) %>% summarize(lat = mean(lat), lon = mean(lon))
ggmap(map.wall) + 
   geom_point(data = trees.err,
              aes(x = lon, y = lat, color = cluster), alpha = 0.4, size = 8) +
   geom_text(data = means, aes(x = lon, y = lat, label = cluster), size = 7, color = "red4", 
             alpha = 0.8) +
   theme_nothing() 
```

Doubling the clusters does the job, at least for the financial district. It's easier to combine multiple clusters together than to split a cluster into a sub-cluster, so this will be the clustering system going forward. 

```{r read corrections, include = FALSE} 
blocks <- readRDS("rds/blocks.corrected.rds")
treeMap <- readRDS("rds/treeMap.corrected.rds") 
trees.err <- readRDS("rds/trees.err.rds") 
```

After [assigning](https://github.com/jwillage/Trees/blob/master/corrections_revised.R) all tree clusters to a block (including manually adding missing blocks), the blocks still require a little further cleanup. All "duplicate" entries (blocks with the same primary street and cross streets) are collapsed into a single entry with a new id. The trees assigned to the collapsed blocks will be assigned the new block ID value. 

```{r collapse blocks}
block.count <- nrow(blocks)
blocks$agg <- blocks %>% group_indices(primary.street, cross1.street, cross2.street) 
treeMap$agg <- right_join(blocks, treeMap, by = c("id" = "blockId"))$agg
blocks <- as.data.table(blocks) 
blocks <- blocks[blocks[, .I[order(agg)[1]], by = agg]$V1, 
                          c("agg", "primary.street", "cross1.street", "cross2.street", "cross1.lat",
                            "cross1.lon", "cross2.lat", "cross2.lon"), with = FALSE]
summary <- treeMap %>% group_by(agg) %>% summarize(trees = n()) %>% as.data.frame()
blocks <- inner_join(summary, blocks, by = c("agg"))
```

This reduces the number of blocks from `r block.count` to `r nrow(blocks)`. Now they can be sorted by tree count.

```{r}
head(blocks[order(blocks$trees, decreasing = TRUE), c(1:5)], 10)
```

The Manhattan block with the highest number of trees is Riverside Dr between 116th St and 119th St, with `r head(blocks[order(blocks$trees, decreasing = TRUE),]$trees, 1)`. While interesting in it's own right, this doesn't take into account the distance of a block. For instance, this "block" along Riverside Dr is clearly 3 blocks long. To reconcile this issue, a slightly different question is asked: Which block has the highest trees-per-meter (TPM)? The TPM approach, as discussed in the [first article](), is applied.  

```{r}
deg2rad <- function(deg) return(deg * pi / 180)

gcd <- function(long1, lat1, long2, lat2) {
  # Computes the great-circle distance between two points using the haversine formula
  #
  # Args:
  #   long1:  Longitude of first point in decimal degrees
  #   lat2:   Latitude of first point in decimal degrees
  #   long2:  Longitude of first point in decimal degrees
  #   lat2:   Latitude of second point in decimal degrees
  #
  # Returns:
  #   The distance in meters
  
  long1 <- deg2rad(long1) 
  lat1 <- deg2rad(lat1)
  long2 <- deg2rad(long2) 
  lat2 <- deg2rad(lat2)
  r <- 6371000
  long.delt <- (long2 - long1)
  lat.delt <- (lat2 - lat1)
  a <- as.numeric(sin(lat.delt / 2)^2 + cos(lat1) * cos(lat2) * sin(long.delt / 2)^2)
  c <- 2 * atan2(sqrt(a), sqrt(1 - a))
  r * c
}
```

Note the application of the Haversine formula assumes all blocks are straight lines from one endpoint to the other. This is generally the case. Other possible solutions could incorporate Google Maps or the segment distances returned from Geonames API. 

```{r}
blocks$cross2.lon <- as.numeric(blocks$cross2.lon)
blocks$cross2.lat <- as.numeric(blocks$cross2.lat)
blocks$cross1.lon <- as.numeric(blocks$cross1.lon)
blocks$cross1.lat <- as.numeric(blocks$cross1.lat)

for (i in 1:nrow(blocks)) { 
  d <- gcd(blocks[i, "cross1.lon"], 
           blocks[i, "cross1.lat"], 
           blocks[i, "cross2.lon"], 
           blocks[i, "cross2.lat"])
  blocks[i, "distance"] <- d 
}

blocks$tpm <- blocks$trees / blocks$distance
```

The process of mapping points to blocks introduced some problematic data; when a second cross street couldn't be determined, the algorithm marked all the related columns as `NA`. In order to have a complete result set, those rows are now imputed with the median TPM. These incomplete blocks can be identified down the line since their second cross street remains null. 

```{r}
blocks[!complete.cases(blocks), "tpm"] <- median(blocks[complete.cases(blocks), "tpm"])
```

At this point the question of which Manhattan block has the highest TPM can be answered. 

```{r, echo = FALSE}
head(blocks[order(blocks$trees, decreasing = TRUE), c(1:5, 11)], 10)
```

The top 25 blocks: 

```{r}
blocks.real <- as.data.frame(blocks.real)
blocks.real$lat.avg <- NULL
blocks.real$lon.avg <- NULL
for (i in 1:nrow(blocks.real)) {
  blocks.real[i, "lat.avg"] <- mean(blocks.real[i, "cross1.lat"], blocks.real[i, "cross2.lat"])
  blocks.real[i, "lon.avg"] <- mean(blocks.real[i, "cross1.lon"], blocks.real[i, "cross2.lon"])
}

top25 <- as.data.frame(head(blocks.real[order(blocks.real$tpm, decreasing = TRUE), ], 25))
top25[, c(2:4, 9:11)]
```

```{r top 25 map}
ggmap(map.manh) + 
   geom_point(data = top25, aes(x = lon.avg, y = lat.avg), size = 6, alpha = 0.5, color = "green") +
   theme_nothing() 
```

Surprisingly, most of the top 25 blocks are in lower Manhattan. Perhaps unsurprisingly, there isn't much in midtown. Here is the tree density over all of Manhattan, by trees per meter. 

```{r hex, eval = F}
ggmap(map.manh) + #1
  coord_cartesian() +
  geom_hex(data = blocks.real, aes(x = lon.avg, y = lat.avg,  tpm), bins = 30) +
  theme_nothing()
+
ggmap(map.manh) + #2
  coord_cartesian() +
  geom_hex(data = treeMap, aes(x = lon, y = lat,  1), bins = 30) +
  theme_nothing()

ggmap(map.manh) + #3 same as 1
  coord_cartesian() +
#  geom_hex(data = blocks.real, aes(x = lon.avg, y = lat.avg,  fill =sum(count)), bins = 30) +
  stat_binhex(data = blocks.real, aes(x = lon.avg, y = lat.avg, color = idx)) +
  theme_nothing()

ggmap(map.manh) +
  coord_cartesian() +
  stat_summary_hex(data = blocks.real, aes(x = lon.avg, y = lat.avg, z = tpm), fun = mean) +
  theme_nothing() +
  scale_fill_gradient(low="lightgreen", high="darkgreen")

ggmap(map.manh) +
  coord_cartesian() +
  stat_summary_hex(data = treeMap, aes(x = lon, y = lat,  z=1), fun = sum) +
  theme_nothing() +
  scale_fill_gradient(low="lightgreen", high="darkgreen")
```


[^1]: **New York City Street Tree Map Beta**  
  Interactive map to view details from a city-wide to a single tree level. No official API  
  https://tree-map.nycgovparks.org/points/\<SW lat>\/\<SW lng\>/\<NE lat\>/\<NE lng\>/undefined/
  \<page\>/\<number trees\>  
  View details of a specific tree, including closest address:  
  https://tree-map.nycgovparks.org/tree/full/\<tree-id from points json\>  
  Browser-based map:  
  https://tree-map.nycgovparks.org/ &nbsp;&nbsp;&nbsp;
  
[^2]: **NYC Open Data**  
  Political and Administrative Boundaries, Borough Boundaries (Clipped to Shoreline)
  http://www1.nyc.gov/site/planning/data-maps/open-data/districts-download-metadata.page&nbsp;&nbsp;&nbsp;